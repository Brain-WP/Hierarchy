Hierarchy
=========

> Hierarchy is package that aims to represent with PHP objects the WordPress template hierarchy.

----------

[![travis-ci status](https://img.shields.io/travis/Giuseppe-Mazzapica/Hierarchy.svg?style=flat-square)](https://travis-ci.org/Giuseppe-Mazzapica/Hierarchy)
[![codecov.io](https://img.shields.io/codecov/c/github/Giuseppe-Mazzapica/Hierarchy.svg?style=flat-square)](http://codecov.io/github/Giuseppe-Mazzapica/Hierarchy?branch=master)
[![license](https://img.shields.io/packagist/l/gmazzap/hierarchy.svg?style=flat-square)](http://opensource.org/licenses/MIT)
[![release](https://img.shields.io/github/release/Giuseppe-Mazzapica/Hierarchy.svg?style=flat-square)](https://github.com/Giuseppe-Mazzapica/Hierarchy/releases/latest)

----------

# TOC

- [What / Why?](#what--why)
- [Template Hierarchy Representation](#template-hierarchy-representation)
- [Template Resolution](#templates-resolution)
  - [Template Resolution Example](#templates-resolution-example)
- [Introducing `QueryTemplate`](#introducing-querytemplate)
  - [Template content is returned](#template-content-is-returned)
  - [Edit template content before to output](#edit-template-content-before-to-output)
  - [Template Finders](#template-finders)
    - [`FoldersTemplateFinder`](#folderstemplatefinder)
      - [Custom file extension](#custom-file-extension)
    - [`SubfolderTemplateFinder`](#subfoldertemplatefinder)
    - [`LocalizedTemplateFinder`](#localizedtemplatefinder)
    - [`SymfonyFinderAdapter`](#symfonyfinderadapter)
    - [`CallbackTemplateFinder`](#callbacktemplatefinder)
  - [Introducing Template Loaders](#introducing-template-loaders)
    - [`FileRequireLoader`](#filerequireloader)
  - [`QueryTemplate` Usage Example For Mustache Templates](#querytemplate-usage-example-for-mustache-templates)
- [Requirements](#requirements)
- [Installation](#installation)
- [Updating from 0.x releases](#updating-from-0x-releases)
  - [0.x Maintenance](#0x-maintenance)
- [License](#license)

-----------

# What / Why?

Every WP developer knows that for every frontend request, WordPress runs a query and then loads a
template file depending on the query.

The choose of template is done according to rules defined in the [**template hierarchy**](https://developer.wordpress.org/themes/basics/template-hierarchy/#the-template-file-hierarchy).

For every query, there's one template.

Now, I want to ask you: **given a query object, which is the function that gives you the template**?

The answer is: such function **dosn't exist**.

The query-to-template resolution is done by WordPress requiring 
[`template_loader.php`](https://github.com/WordPress/WordPress/blob/master/wp-includes/template-loader.php#L58-L79) file
that contains a procedural succession of `if` / `elseif` that looks in template folder and try to find
a template.

It means:

 - There's no way to know which template will be used for a query before the template is loaded
 - There's no way to apply the query-to-template resolution to a query that is not the main query
 - Given a query, there's no way to know which templates WordPress will look for
 
**What this library does is to provide a way to do the 3 things listed above.**
 
 
# Template Hierarchy Representation

Given a query, this library provides a template hierarchy representation in form of a PHP array:

Example:

```php
global $wp_query; // we will show template hierarchy for the main query

$hierarchy = new GM\Hierarchy\Hierarchy();

var_export( $hierarchy->getHierarchy($wp_query) );
```

assuming the query is generated by an url like `example.com/category/foo/page/2` and the category ID for
the term "foo" is 123, the output of code above is:

```php
array(
  'category'  => array( 'category-foo', 'category-123', 'category' ),
  'archive'   => array( 'archive' ),
  'paged'     => array( 'paged' ),
  'index'     => array( 'index' ),
);
```

And if you compare this array with the [visual overview of template hierarchy](https://developer.wordpress.org/files/2014/10/template-hierarchy.png)
you can see that is an accurate representation of the template hierarchy for a category query. 


# Template Resolution

If the question you want to answer is:

> Which templates WordPress will try to find for this query?

It can be simply done using the `getTemplates()` method:

```php
global $wp_query; // we will target the main query

$hierarchy = new GM\Hierarchy\Hierarchy();

var_export( $hierarchy->getTemplates($wp_query) );
```

Assuming same query as above, the output will be:

```php
array(
  'category-foo',
  'category-123',
  'category',
  'archive',
  'paged',
  'index',
);
```

That is the list of templates WordPress will search, in the same order that WordPress will use.

### Template Resolution Example

For this example, I will assume that a theme has template files stored in `templates` subfolder and
using `.phtml` as file extension. 

All the code necessary to load those templates according to template hierarchy is the following:

```php
add_action( 'template_redirect', function() {

    $templates = ( new GM\Hierarchy\Hierarchy() )->getTemplates();
    
    foreach( $templates as $template ) {
      $path = get_template_directory() . "/templates/{$template}.phtml";
      if ( file_exists( $path ) ) {
         require $path;
         exit();
      }
    }
    
} );
```

The example above works, and is just an example of what you can do with this library, however for the
purpose to load templates, this library provide a specific class: `QueryTemplate`.

# Introducing `QueryTemplate`

`QueryTemplate` class makes use of the `Hierarchy` class to get a list of templates to search, then
it looks for those templates and loads the first found.

Example:

```php
add_action( 'template_redirect', function() {

    $queryTemplate = \GM\Hierarchy\QueryTemplate();    
    echo $queryTemplate->loadTemplate();
    
    exit();
    
} );
```

What the code above does, is exactly what WordPress does: the proper template is found in theme folder
and in parent theme folder (if current theme is a child theme) then the first template found is loaded
and its content is output to page.

However, it is **just the default behavior**, and it can be customised.


### Template content is returned

The first thing to note in the last code snippet, is that the template content is **returned** by 
`QueryTemplate::loadTemplate()`.

This is important because without the `echo` what is shown is just a white screen of death.


### Edit template content before to output

Moreover, this feature can be used to alter the content before to output it:

```php
add_action( 'template_redirect', function() {

    $queryTemplate = \GM\Hierarchy\QueryTemplate();    
    $content =  $queryTemplate->loadTemplate();
    
    echo str_replace( 'example.com', 'new.example.com', $content );
    
    exit();
    
} );
```

The snippet above replace every occurrence of `example.com` in the page content with `new.example.com`.

If you are thinking using this method you can use a **template engine** to render templates... you are thinking well,
but sthere's quite a lot more to know.


## Template Finders

By default, `QueryTemplate` class, searches for templates in theme and parent theme folders.

Just like WordPress does.

However, it is possible to use a different template finder class to do something different.

All template finder classes have to implements the `TemplateFinderInterface` interface.

The library comes with some classes that implements that interface, and of course, it is possible to write a custom one.

#### `FoldersTemplateFinder`
 
The class `FoldersTemplateFinder` can be used to search for templates in some **arbitrary** folders,
instead of theme and parent theme folders.
 
Example:

```php
add_action( 'template_redirect', function() {

    $finder = \GM\Hierarchy\Finder\FoldersTemplateFinder([
       __DIR__,
       get_stylesheet_directory(),
       get_template_directory(),
    ]);
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder );  
      
    echo $queryTemplate->loadTemplate();
    
    exit();
    
} );
```

The snippet above will search for templates in the current folder and if template is not found there,
it is searched in theme and parent theme folders.

##### Custom file extension

`FoldersTemplateFinder` class, by default, searches for files with `.php` extension, but is possible to 
use a different files extension, passing it as second constructor argument:

```php
$finder = \GM\Hierarchy\Finder\FoldersTemplateFinder(
    [ get_stylesheet_directory(), get_template_directory() ],
    '.phtml'
);
```

#### `SubfolderTemplateFinder`

This template finder class is very similar to `FoldersTemplateFinder`, however it looks for templates
is a specific subfolder of theme (and parent theme) and use theme (and parent theme) folder as fallback:

```php
add_action( 'template_redirect', function() {

    $finder = \GM\Hierarchy\Finder\SubfolderTemplateFinder('templates');
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

Using code above, the templates are searched, in order, in:

 - /path/to/child/theme/templates/
 - /path/to/parent/theme/templates/
 - /path/to/child/theme/
 - /path/to/parent/theme/
 
`SubfolderTemplateFinder`, just like `FoldersTemplateFinder`, accepts a file extension as second 
constructor argument.
 

#### `LocalizedTemplateFinder`

This finder class works in combination with another finder and allows to load templates based on
the current locale, let's assume:


```php
add_action( 'template_redirect', function() {

    // if no folders provided, theme and parent theme folders are used
    $foldersFinder = new \GM\Hierarchy\Finder\FoldersTemplateFinder();
    
    $finder = new \GM\Hierarchy\Finder\LocalizedTemplateFinder( $foldersFinder );
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

Assuming the current locale is `it_IT`, using code above, the templates are searched, in order, in:

 - /path/to/child/theme/it_IT/
 - /path/to/parent/theme/it_IT/
 - /path/to/child/theme/it/
 - /path/to/parent/theme/it/
 - /path/to/child/theme/
 - /path/to/parent/theme/ 
 
 
#### `SymfonyFinderAdapter`

This class allows to use the [Symfony Finder Component](http://symfony.com/doc/current/components/finder.html)
to find the templates:

```php
add_action( 'template_redirect', function() {

    $symfonyFinder = new \Symfony\Component\Finder\Finder();
    $symfonyFinder = $symfonyFinder->files()->in( __DIR__ )->name('*.phtml');
    
    $finder = new \GM\Hierarchy\Finder\SymfonyFinderAdapter( $symfonyFinder );
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

#### `CallbackTemplateFinder`

This class can be used to easily integrate different loaders with `QueryTemplate` class.

In fact, you need to provide a callback that will be called to find templates.

The callback will receive the template name without file extension, e.g. `index` and has to return

the full path of the template if found, or an empty string if the template is not found.

```php
add_action( 'template_redirect', function() {

    $callback = function( $template ) {       
       return realpath(__DIR__ . $template . '.php') ? : '';
    };
    
    $finder = new \GM\Hierarchy\Finder\CallbackTemplateFinder( $callback );
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

## Introducing Template Loaders

After a template is found with any of the finder classes, `QueryTemplate` has to "load" it.

By default, loading is just a `require` wrapped by `ob_start()` / `ob_get_clean()` so that the template
content is just returned as is.

However, is it possible to process the template in some ways, for example using a **template engine**.

Custom template loaders have to implement `TemplateLoaderInterface` that has just one method: `load()`,
that receives the full path of the template and have to **return** the template content.

Template loaders can be passed as second constructor argument for `QueryTemplate`.


#### `FileRequireLoader`

This is the unique loader class that ships with the library, and it provides the default behavior.


## `QueryTemplate` Usage Example For Mustache Templates

In the following example I will create a loader that renders the template using the PHP implementation of
[Mustache template engine](https://github.com/bobthecow/mustache.php):

```php
namespace My\Theme;

use GM\Hierarchy\Finder\SubfolderTemplateFinder;
use GM\Hierarchy\Loader\TemplateLoaderInterface;
use Mustache_Engine;

class MustacheLoader implements TemplateLoaderInterface  {

   private $engine;

   public function __construct(Mustache_Engine $engine) {
      $this->engine = $engine;
   }

   public function load($templatePath) {
        $data = apply_filters( 'my_theme_data', ['query' => $GLOBALS['wp_query'], $templatePath );
        $template = file_get_contents($templatePath);
        
        return $this->engine->render( $template, $data );
   }
}

add_action( 'template_redirect', function() {
    
    // will look for "*.mustache" templates in "/templates" subfolder of theme
    $finder = new SubfolderTemplateFinder('templates', 'mustache');
    
    // make use of the class above
    $loader = new MustacheLoader( new Mustache_Engine() ); 
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder, $loader ); 
    
    // load the rendered template
    $content = $queryTemplate->loadTemplate();
    
    // if content isn't empty, output it and exit, otherwise WordPress will continue its work
    if ( trim( $content ) ) {
        echo $content;
        exit();
    }
      
} );
```

# Requirements

Hierarchy requires **PHP 5.5+** and [Composer](https://getcomposer.org/) to be installed.


# Installation

Best served by Composer, package name is `gmazzap/hierarchy`.

 
# Updating from 0.x releases

The 1.x versions are **incompatible** with 0.x releases.

Generally speaking:

 - `Hierarchy` class namespace has been changed from `GM` to `GM\Hierarchy`
    (so fully-qualified class name from `GM\Hierarchy` to `GM\Hierarchy\Hierarchy`)
 - `Hierarchy::get()` is replaced by `Hierarchy::getHierarchy()`
 - `Hierarchy::getFlat()` is replaced by `Hierarchy::getTemplates()`
 - `Hierarchy::findTemplateUsing()` is removed, template finding / loading is done via the new `QueryTemplate` class
 
### 0.x Maintenance

I'll try to update 0.x releases, if any bug is found or if something is changed in WordPress 
(e.g. when the new `singular.php` template was added), but I will not add new features there.


# License

Hierarchy is released under MIT.
