Hierarchy
=========

Hierarchy is package that aims to represent with PHP objects the WordPress template hierarchy.

# What / Why?

Every WP developer knows that for every frontend request, WordPress runs a query and then loads a
template file depending on the query.
The template choose is done by rules defined in the [**template hierarchy**](https://developer.wordpress.org/themes/basics/template-hierarchy/#the-template-file-hierarchy).

For very query, there's one template.

Now, I want to ask you, given a query object, which is the function / method that gives you the template?

The answer is: **dosn't exist** such function or method.

The query to template resolution is done by WordPress requiring the 
[`template_loader.php`](https://github.com/WordPress/WordPress/blob/master/wp-includes/template-loader.php#L58-L79) file
that contains a procedural succession of `if` / `elseif` that looks in template folder and try to find
a template.

It means:

 - There's no way to know which template belongs to a query before the template is loaded
 - There's no way to apply the query to template resolution to a query that is not a main query
 - Give a query, there's no way to know which templates WordPress will look for
 
**What this library does is to provide a way to do the 3 things listed above.**
 
 
# Template Hierarchy Representation

Given a query, this library provides a template hierarchy representation in form of a PHP array:

Example:

```php
global $wp_query; // we will show template hierarchy for the main query

$hierarchy = new GM\Hierarchy\Hierarchy();

var_export( $hierarchy->getHierarchy($wp_query) );
```

assuming the query is generated by an url like `example.com/category/foo/page/2` and the category ID for
the term "foo" is 123, the output of code above is:

```php
array(
  'category'  => array( 'category-foo', 'category-123', 'category' ),
  'archive'   => array( 'archive' ),
  'paged'    => array( 'paged' ),
  'index'     => array( 'index' ),
);
```

And if you compare this array with the [visual overview of template hierarchy](https://developer.wordpress.org/files/2014/10/template-hierarchy.png)
you can see that is an accurate representation of the template hierarchy for a category query. 


# Templates Resolution

If the question you want to answer is:

> Which templates WordPress will look for for this query?

It can be simply done using the `getTemplates()` method:

```php
global $wp_query; // we will show template hierarchy for the main query

$hierarchy = new GM\Hierarchy\Hierarchy();

var_export( $hierarchy->getTemplates($wp_query) );
```

Assuming same query as above, the output will be:

```php
array(
  'category-foo',
  'category-123',
  'category',
  'archive',
  'paged',
  'index',
);
```

That is the list of templates WordPress will search, in the same order that WordPress will use.

### Example

For this example, I will assume that a theme has template files stored in `templates` subfolder and
using `.phtml` as file extension. 

All the code necessary to load those templates following template hierarchy is this:

```php
add_action( 'template_redirect', function() {

    $templates = ( new GM\Hierarchy\Hierarchy() )->getTemplates();
    
    foreach( $templates as $template ) {
      $path = get_template_directory() . "/templates/{$template}.phtml";
      if ( file_exists( $path ) ) {
         require $path;
         exit();
      }
    }
    
} );
```

The example above works, and is just an example of what you can do with this library, however for the
purpose to load templates, this library provide a specific class: `QueryTemplate`.

# Introducing `QueryTemplate`

`QueryTemplate` class makes use of the `Hierarchy` class to get a list of templates to search for, then it looks
for those template and loads the first found.

Example:

```php
add_action( 'template_redirect', function() {

    $queryTemplate = \GM\Hierarchy\QueryTemplate();    
    echo $queryTemplate->loadTemplate();
    
    exit();
    
} );
```

What this code above does, is exactly what WordPress does: the proper template is found in theme folder
and in parent theme folder (if current theme is a child theme) then the first template found is loaded
and its content is output to page.

However, it is **just the default behavior**, and it can be customised a lot.


### Template content is returned

The first thing to note in the last code snippet, is that the template content is **returned** by 
`QueryTemplate::loadTemplate()`.

This is important because without the `echo` what is shown is just a white screen of death.


### Edit template content before to output

Moreover, this feature can be used to alter the content before to output it:

```php
add_action( 'template_redirect', function() {

    $queryTemplate = \GM\Hierarchy\QueryTemplate();    
    $content =  $queryTemplate->loadTemplate();
    
    echo str_replace( 'example.com', 'new.example.com', $content );
    
    exit();
    
} );
```

The snippet above replace every occurrence of `example.com` in the page content with `new.example.com`.

If you are thinking using this method you can use a **template engine** to render templates... you are thinking well,
but surprised are not finished yet.


## Template Finders

By default, `QueryTemplate` class, search for templates in theme and parent theme folders.
Just like WordPress does.

However, it is possible to use a different template finder class to do something different.

All template finder classes have to implements the `TemplateFinderInterface` interface.

The library comes with some classes that implements that interface, and of course, it is possible to write a custom one.

#### `FoldersTemplateFinder`
 
The class `FoldersTemplateFinder` can be used to search for templates in some **arbitrary** folders,
instead of theme and parent theme folders.
 
Example:

```php
add_action( 'template_redirect', function() {

    $uploadDir = wp_upload_dir();

    $finder = \GM\Hierarchy\Finder\FoldersTemplateFinder([
       $uploadDir['basedir']['templates'],
       get_stylesheet_directory(),
       get_template_directory(),
    ]);
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder );  
      
    echo $queryTemplate->loadTemplate();
    
    exit();
    
} );
```

The snippet above will search for templates in the subfolder `/templates` of the WordPress upload folder,
and after that, if template is not found there, it is searched in theme and parent theme folders.

##### Custom file extension

`FoldersTemplateFinder` class, by default search for files with `.php` extension, but is possible to 
use a different files extension, passing it as second constructor argument:

```php
$finder = \GM\Hierarchy\Finder\FoldersTemplateFinder(
    [ get_stylesheet_directory(), get_template_directory() ],
    '.phtml'
);
```

#### `SubfolderTemplateFinder`

This template finder class is very similar to `FoldersTemplateFinder`, however it looks for templates
is a specific subfolder of theme (and parent theme) and use theme (and parent theme) folder as fallback:

```php
add_action( 'template_redirect', function() {

    $finder = \GM\Hierarchy\Finder\SubfolderTemplateFinder('templates');
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

Using code above, the templates are searched, in order, in:

 - /path/to/child/theme/templates/
 - /path/to/parent/theme/templates/
 - /path/to/child/theme/
 - /path/to/parent/theme/
 
`SubfolderTemplateFinder`, just like `FoldersTemplateFinder`, accepts a file extension as second 
constructor argument.
 

#### `LocalizedTemplateFinder`

This finder class works in combination with another finder (it is a decorator) and allows to load
templates based on the current locale, let's assume:


```php
add_action( 'template_redirect', function() {

    // if no folders provided, theme and parent theme folders are used
    $foldersFinder = new \GM\Hierarchy\Finder\FoldersTemplateFinder();
    
    $finder = new \GM\Hierarchy\Finder\LocalizedTemplateFinder($foldersFinder);
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

Assuming the current locale is `it_IT`, using code above, the templates are searched, in order, in:

 - /path/to/child/theme/it_IT/
 - /path/to/parent/theme/it_IT/
 - /path/to/child/theme/it/
 - /path/to/parent/theme/it/
 - /path/to/child/theme/
 - /path/to/parent/theme/ 
 
 
#### `SymfonyTemplateFinderAdapter`

This class allows to use the [Symfony Finder Component](http://symfony.com/doc/current/components/finder.html)
to find the templates:

```php
add_action( 'template_redirect', function() {

    $symfonyFinder = new \Symfony\Component\Finder\Finder();
    $symfonyFinder = $symfonyFinder->files()->in( __DIR__ )->name('*.phtml');
    
    $finder = new \GM\Hierarchy\Finder\SymfonyTemplateFinderAdapter($symfonyFinder);
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

#### `CallbackTemplateFinder`

This class can be used to easily integrate different loaders with `QueryTemplate` class.

In fact, you need to provide a callback that will be called to find the template.

The callback will receive the template name without file extension, e.g. `index` and has to return

the full path of the template if is found, or an empty string if the template is not found.

```php
add_action( 'template_redirect', function() {

    $callback = function($template) {       
       return realpath(__DIR__ . $template . '.php') ? : '';
    };
    
    $finder = new \GM\Hierarchy\Finder\CallbackTemplateFinder($callback);
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

## `Introducing Template Loaders

After a template is found with any of the finder, `QueryTemplate` has to "load" it.+

By default, loading is just a `require` wrapped by `ob_start()` / `ob_get_clean()` so that the template
content is just returned as is.

However, is it possible to process the template in some ways, for example using a **template engine**.

Custom template loaders have to implements `TemplateLoaderInterface`, it has just one method: `load()`,
that receives the full path of the template and have to **return** the template content.

Template loaders can be passed as second constructor argument for `QueryTemplate`.


#### `FileRequireLoader`

This is the unique loader class that ships with the library, and it provide the default behavior.


## Customized `QueryTemplate` Example

In the following example I will create a loader that renders the template using the PHP implementation of
[Mustache template engine](https://github.com/bobthecow/mustache.php):

```php
namespace My\Theme;

use GM\Hierarchy\Finder\SubfolderTemplateFinder;
use GM\Hierarchy\Loader\TemplateLoaderInterface;
use Mustache_Engine;

class MustacheLoader implements TemplateLoaderInterface  {

   private $engine;

   public function __construct(Mustache_Engine $engine) {
      $this->engine = $engine;
   }

   public function load($templatePath) {
        $data = apply_filters( 'my_theme_data', ['query' => $GLOBALS['wp_query'], $templatePath );
        $template = file_get_contents($templatePath);
        
        return $this->engine->render( $template, $data );
   }
}

add_action( 'template_redirect', function() {
    
    $finder = new SubfolderTemplateFinder('templates', 'mustache');
    $loader = new MustacheLoader( new Mustache_Engine() ); 
    
    $queryTemplate = \GM\Hierarchy\QueryTemplate( $finder, $loader ); 
    
    echo $queryTemplate->loadTemplate();
    exit();
} );
```

# Requirements

Hierarchy requires **PHP 5.5+** and [Composer](https://getcomposer.org/) to be installed.


# Installation

Best served by Composer with name `gmazzap/hierarchy`.

 
# Updating from 0.x releases

The current version 1.0 is **incompatible** with 0.x releases.

Generally speaking:

 - `Hierarchy` class namespace has been changed from `GM` to `GM\Hierarchy`
    (so fully-qualified class name from `GM\Hierarchy` to `GM\Hierarchy\Hierarchy`)
 - `Hierarchy::get()` is replaced by `Hierarchy::getHierarchy()`
 - `Hierarchy::getFlat()` is replaced by `Hierarchy::getTemplates()`
 - `Hierarchy::findTemplateUsing()` is removed, template finding / loading is done via the new `QueryTemplate` class
 
### 0.x Maintenance

I'll try to update 0.x releases, if any bug is found or if something is changed in WordPress 
(e.g. when the new `singular.php` template was added) but I will not add new features there.


# License

Hierarchy is released under MIT.
